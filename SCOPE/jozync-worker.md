# Jožin Worker — Sync (jozync)

## Purpose
The **jozync worker** acts as a synchronization layer between the local JSON sidecars and the central database. It ensures data consistency between what the analysis workers (like `jozan-scan`) produce and what the user edits or the application modifies.

Its main goal is to keep both sources — filesystem and database — perfectly in sync without ever overwriting user changes unintentionally.

---

## Responsibilities
1. **Import** sidecar data into the database.
   - Read all JSON files generated by other workers (e.g., `jozan`).
   - Validate against JSON Schemas.
   - Write new or updated entries into the database’s *file data schema*.

2. **Write back** user modifications.
   - Detect which database records have been changed by users (e.g., renamed, tagged, rated).
   - Merge those changes into the corresponding JSON sidecars.
   - Maintain synchronization status fields (`synced`, `dirty`).

3. **Conflict resolution & consistency checks.**
   - Detect conflicts between modified JSON and updated database records.
   - Apply deterministic conflict resolution (user changes override by default).
   - Flag inconsistent states for manual review.

4. **Incremental synchronization.**
   - Detect changed files based on modification timestamps and hash comparisons.
   - Sync only dirty records to minimize I/O and file writes.

---

## Database Structure

### 1. File Data Schema
- Contains all information extracted directly from files (via workers such as `jozan`).
- Only the **jozync worker** may modify these records.
- During rescans, this data can be refreshed or replaced safely.

Example table:
```sql
CREATE TABLE file_data (
  id TEXT PRIMARY KEY,
  path TEXT NOT NULL,
  format TEXT,
  width INT,
  height INT,
  exif JSONB,
  hashes JSONB,
  eus BIGINT,
  last_scanned TIMESTAMP,
  version TEXT
);
```

### 2. User Data Schema

- Contains only user-defined or application-defined customizations.
- Users can override or extend properties of file_data entries.
- Merged at runtime with the original file data.

Example table:
```sql
CREATE TABLE user_data (
  file_id TEXT REFERENCES file_data(id) ON DELETE CASCADE,
  alias TEXT,
  tags TEXT[],
  rating INT,
  favorite BOOLEAN DEFAULT FALSE,
  notes TEXT,
  custom JSONB,
  last_modified TIMESTAMP
);
```

---

## Write-Back & Synchronization Logic

When writing changes back to disk:

**Base layer**: Fields from file data (immutable, original scan output).
**User layer**: Fields from user data schema overriding the base.
**Merged result**: Saved to JSON sidecar, preserving both.

### Status Tracking Fields

Each sidecar includes hidden sync status fields:
```json
"sync": {
  "written": true,
  "dirty": false,
  "lastWrite": "2025-10-13T15:05:00Z"
}
```

Rules:

- `written = true` → file is up-to-date with DB.
- `dirty = true` → DB changes exist that need to be written to file.
- `dirty = false` → no unsynced changes.

The worker only rewrites files where `dirty = true` or source data changed.

---

## CLI Design

```bash
jozync [options] <path>

Options:
  -i, --import             Import JSON files into the database
  -e, --export             Export user changes from DB back to JSON files
  -d, --db <url>           Database connection string
  -p, --path <dir>         Root directory for JSON sidecars
  -c, --check              Verify sync integrity without modifying files
  -j, --jobs <n>           Parallel jobs (default: CPU cores)
  -v, --verbose            Verbose output
  -q, --quiet              Minimal output
  -h, --help               Show usage
```

---

## Synchronization Strategy

- Hash-based: Compare content hash of sidecar vs DB record to detect divergence.
- Timestamp-based: If DB last_modified > JSON lastWrite, update file.
- Conflict detection: If both changed since last sync, mark conflict → manual review.
- Batch mode: Group writes into transactional batches to minimize DB round-trips.

---

## Performance Targets

- Import ≥ 500 JSON sidecars/sec (SSD)
- Sync write-back ≤ 10 ms per file (batch mode)
- Memory footprint ≤ 200 MB for 100k files

---

## Future Extensions

- Change-tracking triggers for live sync (Postgres LISTEN/NOTIFY).
- Background queue for async updates.
- User-level rollback/restore of metadata.
- WebSocket push notifications for UI sync state.

---

## Acceptance Criteria

- Imports and exports data accurately without loss.
- Merges user data with file data deterministically.
- Updates only dirty records.
- Passes JSON schema validation for every write.
- Reversible operation — re-importing produces identical DB state.
