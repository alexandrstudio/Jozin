//! Cleanup module - Remove Jožin-generated files
//!
//! This module provides safe removal of files generated by Jožin:
//! - JSON sidecar files (`*.json`)
//! - Backup files (`*.json.bak1`, `*.json.bak2`, `*.json.bak3`)
//! - Thumbnail files (`*_<size>.jpg`, `*_<size>.webp`)
//! - Cache directories (`.jozin/`)
//!
//! ## Safety Guarantees
//!
//! - **Pattern-based detection**: Only files matching Jožin's strict patterns are deleted
//! - **Original preservation**: Original image files are never touched
//! - **Dry-run preview**: See what will be deleted before committing
//! - **Detailed reporting**: Every deletion is logged with file type and size
//! - **Error resilience**: Failed deletions are reported but don't stop the operation
//!
//! ## Usage
//!
//! ```no_run
//! use jozin_core::cleanup::{cleanup_path, CleanupOptions};
//! use std::path::Path;
//!
//! // Remove all Jožin files (dry-run)
//! let options = CleanupOptions::all();
//! let result = cleanup_path(
//!     Path::new("/photos"),
//!     true,  // recursive
//!     options,
//!     true,  // dry_run
//!     None,  // progress_callback
//! )?;
//! println!("Would delete {} files ({} bytes)", result.total_files, result.total_bytes);
//!
//! // Remove only sidecars
//! let options = CleanupOptions::sidecars_only();
//! let result = cleanup_path(Path::new("/photos"), true, options, false, None)?;
//! # Ok::<(), jozin_core::JozinError>(())
//! ```

use crate::{JozinError, Result};
use serde::{Deserialize, Serialize};
use std::fs;
use std::path::Path;
use walkdir::WalkDir;

// ============================================================================
// Public Types
// ============================================================================

/// Options controlling which types of files to delete.
///
/// Use the convenience constructors:
/// - `CleanupOptions::all()` - Delete everything
/// - `CleanupOptions::sidecars_only()` - Only JSON sidecars
/// - `CleanupOptions::thumbnails_only()` - Only thumbnails
/// - `CleanupOptions::backups_only()` - Only backup files
/// - `CleanupOptions::cache_only()` - Only cache directories
#[derive(Debug, Clone, Copy)]
pub struct CleanupOptions {
    /// Delete JSON sidecar files (*.json)
    pub sidecars: bool,
    /// Delete thumbnail files (*_<size>.jpg/webp)
    pub thumbnails: bool,
    /// Delete backup files (*.json.bakN)
    pub backups: bool,
    /// Delete cache directories (.jozin/)
    pub cache: bool,
}

impl CleanupOptions {
    /// Delete all Jožin-generated files (default behavior)
    pub fn all() -> Self {
        Self {
            sidecars: true,
            thumbnails: true,
            backups: true,
            cache: true,
        }
    }

    /// Delete only JSON sidecar files
    pub fn sidecars_only() -> Self {
        Self {
            sidecars: true,
            thumbnails: false,
            backups: false,
            cache: false,
        }
    }

    /// Delete only thumbnail files
    pub fn thumbnails_only() -> Self {
        Self {
            sidecars: false,
            thumbnails: true,
            backups: false,
            cache: false,
        }
    }

    /// Delete only backup files
    pub fn backups_only() -> Self {
        Self {
            sidecars: false,
            thumbnails: false,
            backups: true,
            cache: false,
        }
    }

    /// Delete only cache directories
    pub fn cache_only() -> Self {
        Self {
            sidecars: false,
            thumbnails: false,
            backups: false,
            cache: true,
        }
    }
}

/// Result of a cleanup operation.
///
/// Contains detailed information about all files that were (or would be) deleted,
/// including their types, sizes, and any errors encountered.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CleanupResult {
    /// List of all deleted files with details
    pub deleted_files: Vec<DeletedFile>,
    /// Total number of files processed
    pub total_files: usize,
    /// Total size of deleted files in bytes
    pub total_bytes: u64,
    /// Number of files that failed to delete
    pub failed: usize,
}

/// Information about a single deleted file.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DeletedFile {
    /// Path to the deleted file
    pub path: String,
    /// Type of file (sidecar, thumbnail, backup, cache)
    pub file_type: FileType,
    /// Size in bytes (0 if size couldn't be determined)
    pub size_bytes: u64,
    /// Error message if deletion failed
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error: Option<String>,
}

/// Type of Jožin-generated file.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum FileType {
    /// JSON sidecar file (*.json)
    Sidecar,
    /// Backup file (*.json.bak1, *.json.bak2, *.json.bak3)
    Backup,
    /// Thumbnail file (*_<size>.jpg, *_<size>.webp)
    Thumbnail,
    /// Cache directory file (.jozin/*)
    Cache,
}

// ============================================================================
// Public API
// ============================================================================

/// Removes Jožin-generated files from a path (file or directory).
///
/// This is the main entry point for the cleanup module. It handles both
/// single files and directory trees with recursive traversal.
///
/// # Arguments
///
/// * `path` - File or directory to clean
/// * `recursive` - Enable recursive directory traversal
/// * `options` - Control which file types to delete
/// * `dry_run` - Preview mode: show what would be deleted without actually deleting
/// * `progress_callback` - Optional callback for real-time progress reporting
///
/// # Returns
///
/// Returns a `CleanupResult` containing:
/// - List of deleted (or would-be deleted) files
/// - Total count and size
/// - Number of failed deletions
///
/// # Errors
///
/// - `JozinError::IoError` if path doesn't exist or cannot be accessed
///
/// Individual file deletion failures do not fail the entire operation;
/// they are captured in the `failed` count and returned with error details.
///
/// # Examples
///
/// ```no_run
/// use jozin_core::cleanup::{cleanup_path, CleanupOptions};
/// use std::path::Path;
///
/// // Dry-run: preview what will be deleted
/// let result = cleanup_path(
///     Path::new("/photos"),
///     true,
///     CleanupOptions::all(),
///     true,
///     None,  // progress_callback
/// )?;
/// println!("Would delete {} files", result.total_files);
///
/// // Actually delete sidecars only
/// let result = cleanup_path(
///     Path::new("/photos"),
///     true,
///     CleanupOptions::sidecars_only(),
///     false,
///     None,  // progress_callback
/// )?;
/// println!("Deleted {} files", result.total_files);
/// # Ok::<(), jozin_core::JozinError>(())
/// ```
pub fn cleanup_path(
    path: &Path,
    recursive: bool,
    options: CleanupOptions,
    dry_run: bool,
    progress_callback: Option<&dyn Fn(crate::ProgressEvent)>,
) -> Result<CleanupResult> {
    // Validate path exists
    if !path.exists() {
        return Err(JozinError::IoError {
            message: format!("Path not found: {}", path.display()),
        });
    }

    // Handle single file
    if path.is_file() {
        return cleanup_single_file(path, options, dry_run);
    }

    // Handle directory
    if path.is_dir() {
        return cleanup_directory(path, recursive, options, dry_run, progress_callback);
    }

    // Path exists but is neither file nor directory
    Err(JozinError::ValidationError {
        message: format!("Path is neither a file nor a directory: {}", path.display()),
    })
}

// ============================================================================
// Internal Helpers
// ============================================================================

/// Cleans up a single file if it matches Jožin patterns.
fn cleanup_single_file(
    file_path: &Path,
    options: CleanupOptions,
    dry_run: bool,
) -> Result<CleanupResult> {
    let mut result = CleanupResult {
        deleted_files: Vec::new(),
        total_files: 0,
        total_bytes: 0,
        failed: 0,
    };

    if let Some(file_type) = classify_file(file_path) {
        if should_delete(file_type, options) {
            let size = fs::metadata(file_path).ok().map(|m| m.len()).unwrap_or(0);

            result.total_files = 1;
            result.total_bytes = size;

            if !dry_run {
                match fs::remove_file(file_path) {
                    Ok(_) => {
                        result.deleted_files.push(DeletedFile {
                            path: file_path.display().to_string(),
                            file_type,
                            size_bytes: size,
                            error: None,
                        });
                    }
                    Err(e) => {
                        result.failed = 1;
                        result.deleted_files.push(DeletedFile {
                            path: file_path.display().to_string(),
                            file_type,
                            size_bytes: size,
                            error: Some(e.to_string()),
                        });
                    }
                }
            } else {
                result.deleted_files.push(DeletedFile {
                    path: file_path.display().to_string(),
                    file_type,
                    size_bytes: size,
                    error: None,
                });
            }
        }
    }

    Ok(result)
}

/// Cleans up a directory recursively or non-recursively.
fn cleanup_directory(
    dir_path: &Path,
    recursive: bool,
    options: CleanupOptions,
    dry_run: bool,
    progress_callback: Option<&dyn Fn(crate::ProgressEvent)>,
) -> Result<CleanupResult> {
    let mut result = CleanupResult {
        deleted_files: Vec::new(),
        total_files: 0,
        total_bytes: 0,
        failed: 0,
    };

    // Configure directory walker
    let walker = if recursive {
        WalkDir::new(dir_path)
    } else {
        WalkDir::new(dir_path).max_depth(1)
    };

    // Iterate through directory entries
    for entry in walker {
        // Handle walkdir errors (permission denied, etc.)
        let entry = match entry {
            Ok(e) => e,
            Err(e) => {
                eprintln!("Warning: Failed to access entry: {}", e);
                continue;
            }
        };

        let path = entry.path();

        // Handle cache directories specially
        if options.cache && is_cache_directory(path) {
            // Delete entire cache directory recursively
            if let Err(e) = delete_cache_directory(path, dry_run, &mut result) {
                eprintln!("Warning: Failed to delete cache directory {}: {}", path.display(), e);
            }
            continue;
        }

        // Skip directories (we only delete files, except for cache dirs above)
        if !path.is_file() {
            continue;
        }

        // Classify and potentially delete file
        if let Some(file_type) = classify_file(path) {
            if should_delete(file_type, options) {
                let size = fs::metadata(path).ok().map(|m| m.len()).unwrap_or(0);

                result.total_files += 1;
                result.total_bytes += size;

                // Emit FileStarted event
                if let Some(callback) = progress_callback {
                    callback(crate::ProgressEvent::FileStarted {
                        path: path.display().to_string(),
                    });
                }

                if !dry_run {
                    match fs::remove_file(path) {
                        Ok(_) => {
                            result.deleted_files.push(DeletedFile {
                                path: path.display().to_string(),
                                file_type,
                                size_bytes: size,
                                error: None,
                            });

                            // Emit FileCompleted event (success)
                            if let Some(callback) = progress_callback {
                                callback(crate::ProgressEvent::FileCompleted {
                                    path: path.display().to_string(),
                                    success: true,
                                    error: None,
                                    size_bytes: Some(size),
                                });
                            }
                        }
                        Err(e) => {
                            result.failed += 1;
                            result.deleted_files.push(DeletedFile {
                                path: path.display().to_string(),
                                file_type,
                                size_bytes: size,
                                error: Some(e.to_string()),
                            });

                            // Emit FileCompleted event (failure)
                            if let Some(callback) = progress_callback {
                                callback(crate::ProgressEvent::FileCompleted {
                                    path: path.display().to_string(),
                                    success: false,
                                    error: Some(e.to_string()),
                                    size_bytes: Some(size),
                                });
                            }
                        }
                    }
                } else {
                    result.deleted_files.push(DeletedFile {
                        path: path.display().to_string(),
                        file_type,
                        size_bytes: size,
                        error: None,
                    });

                    // Emit FileCompleted event (dry-run)
                    if let Some(callback) = progress_callback {
                        callback(crate::ProgressEvent::FileCompleted {
                            path: path.display().to_string(),
                            success: true,
                            error: None,
                            size_bytes: Some(size),
                        });
                    }
                }
            }
        }
    }

    Ok(result)
}

/// Classifies a file as a Jožin-generated type or None if it's not a Jožin file.
fn classify_file(path: &Path) -> Option<FileType> {
    if is_sidecar_file(path) {
        Some(FileType::Sidecar)
    } else if is_backup_file(path) {
        Some(FileType::Backup)
    } else if is_thumbnail_file(path) {
        Some(FileType::Thumbnail)
    } else if is_cache_file(path) {
        Some(FileType::Cache)
    } else {
        None
    }
}

/// Checks if a file should be deleted based on its type and cleanup options.
fn should_delete(file_type: FileType, options: CleanupOptions) -> bool {
    match file_type {
        FileType::Sidecar => options.sidecars,
        FileType::Backup => options.backups,
        FileType::Thumbnail => options.thumbnails,
        FileType::Cache => options.cache,
    }
}

/// Checks if a file is a JSON sidecar file.
///
/// Pattern: `IMG_1234.JPG.json`
/// Must end with `.json` and the stem must contain a dot (indicating an image file extension).
/// This avoids deleting standalone JSON files like `config.json` or `document.json`.
fn is_sidecar_file(path: &Path) -> bool {
    // Must end with .json
    if path.extension().and_then(|e| e.to_str()) != Some("json") {
        return false;
    }

    let file_name = match path.file_name().and_then(|n| n.to_str()) {
        Some(name) => name,
        None => return false,
    };

    // Check it's a pure .json file (not .json.bak1, etc.)
    if !file_name.ends_with(".json") || file_name.contains(".json.") {
        return false;
    }

    // Get the stem (filename without .json extension)
    let stem = match path.file_stem().and_then(|s| s.to_str()) {
        Some(s) => s,
        None => return false,
    };

    // Stem must contain a dot (e.g., "IMG_1234.JPG" has a dot)
    // This indicates it's a sidecar for an image file, not a standalone JSON
    stem.contains('.')
}

/// Checks if a file is a backup file.
///
/// Pattern: `IMG_1234.JPG.json.bak1`, `IMG_1234.JPG.json.bak2`, `IMG_1234.JPG.json.bak3`
fn is_backup_file(path: &Path) -> bool {
    let file_name = match path.file_name().and_then(|n| n.to_str()) {
        Some(name) => name,
        None => return false,
    };

    file_name.ends_with(".json.bak1")
        || file_name.ends_with(".json.bak2")
        || file_name.ends_with(".json.bak3")
}

/// Checks if a file is a thumbnail file.
///
/// Pattern: `IMG_1234_256.jpg`, `IMG_1234_512.webp`, etc.
/// Format: `<base>_<digits>.<jpg|webp>`
///
/// To avoid false positives, we check:
/// - Extension must be jpg or webp
/// - Must end with _<digits> where digits are 2-4 characters
/// - The digit value must be in reasonable thumbnail size range (32-4096)
fn is_thumbnail_file(path: &Path) -> bool {
    let file_name = match path.file_stem().and_then(|s| s.to_str()) {
        Some(name) => name,
        None => return false,
    };

    let extension = match path.extension().and_then(|e| e.to_str()) {
        Some(ext) => ext.to_lowercase(),
        None => return false,
    };

    // Check extension is jpg or webp
    if extension != "jpg" && extension != "webp" {
        return false;
    }

    // Check for pattern: ends with _<digits>
    if let Some(underscore_pos) = file_name.rfind('_') {
        let before_underscore = &file_name[..underscore_pos];
        let after_underscore = &file_name[underscore_pos + 1..];

        // Must have substantial content before the underscore (at least 5 chars)
        // This helps distinguish IMG_1234.jpg (original) from IMG_1234_256.jpg (thumbnail)
        if before_underscore.len() < 5 {
            return false;
        }

        // Must be all digits
        if !after_underscore.chars().all(|c| c.is_ascii_digit()) || after_underscore.is_empty() {
            return false;
        }

        // Digit string should be 2-4 characters (thumbnail sizes: 64, 256, 1024, etc.)
        if after_underscore.len() < 2 || after_underscore.len() > 4 {
            return false;
        }

        // Parse and check if it's in reasonable thumbnail size range (32-4096)
        if let Ok(size) = after_underscore.parse::<u32>() {
            size >= 32 && size <= 4096
        } else {
            false
        }
    } else {
        false
    }
}

/// Checks if a file is inside a cache directory.
fn is_cache_file(path: &Path) -> bool {
    path.components().any(|c| {
        if let Some(name) = c.as_os_str().to_str() {
            name == ".jozin"
        } else {
            false
        }
    })
}

/// Checks if a path is a cache directory itself.
fn is_cache_directory(path: &Path) -> bool {
    path.is_dir()
        && path
            .file_name()
            .and_then(|n| n.to_str())
            .map(|n| n == ".jozin")
            .unwrap_or(false)
}

/// Deletes a cache directory and all its contents.
fn delete_cache_directory(
    cache_dir: &Path,
    dry_run: bool,
    result: &mut CleanupResult,
) -> Result<()> {
    // Walk the cache directory to count files and sizes
    for entry in WalkDir::new(cache_dir) {
        let entry = entry?;
        if entry.path().is_file() {
            let size = fs::metadata(entry.path()).ok().map(|m| m.len()).unwrap_or(0);
            result.total_files += 1;
            result.total_bytes += size;

            result.deleted_files.push(DeletedFile {
                path: entry.path().display().to_string(),
                file_type: FileType::Cache,
                size_bytes: size,
                error: None,
            });
        }
    }

    // Delete the directory
    if !dry_run {
        fs::remove_dir_all(cache_dir)?;
    }

    Ok(())
}

// ============================================================================
// Tests
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::PathBuf;
    use tempfile::TempDir;

    fn create_test_file(dir: &Path, filename: &str, content: &[u8]) -> PathBuf {
        let path = dir.join(filename);
        if let Some(parent) = path.parent() {
            fs::create_dir_all(parent).unwrap();
        }
        fs::write(&path, content).unwrap();
        path
    }

    #[test]
    fn test_is_sidecar_file() {
        assert!(is_sidecar_file(Path::new("IMG_1234.JPG.json")));
        assert!(is_sidecar_file(Path::new("/path/to/photo.png.json")));
        assert!(!is_sidecar_file(Path::new("IMG_1234.JPG.json.bak1")));
        assert!(!is_sidecar_file(Path::new("IMG_1234.JPG")));
        assert!(!is_sidecar_file(Path::new("document.json")));  // This is a sidecar too
    }

    #[test]
    fn test_is_backup_file() {
        assert!(is_backup_file(Path::new("IMG_1234.JPG.json.bak1")));
        assert!(is_backup_file(Path::new("IMG_1234.JPG.json.bak2")));
        assert!(is_backup_file(Path::new("IMG_1234.JPG.json.bak3")));
        assert!(!is_backup_file(Path::new("IMG_1234.JPG.json")));
        assert!(!is_backup_file(Path::new("IMG_1234.JPG.json.bak")));
        assert!(!is_backup_file(Path::new("IMG_1234.JPG")));
    }

    #[test]
    fn test_is_thumbnail_file() {
        assert!(is_thumbnail_file(Path::new("IMG_1234_256.jpg")));
        assert!(is_thumbnail_file(Path::new("IMG_1234_512.webp")));
        assert!(is_thumbnail_file(Path::new("photo_1024.jpg")));
        assert!(!is_thumbnail_file(Path::new("IMG_1234.jpg")));
        assert!(!is_thumbnail_file(Path::new("IMG_1234_thumb.jpg")));
        assert!(!is_thumbnail_file(Path::new("IMG_1234_256.png")));
    }

    #[test]
    fn test_is_cache_file() {
        assert!(is_cache_file(Path::new("/photos/.jozin/cache.db")));
        assert!(is_cache_file(Path::new(".jozin/file.txt")));
        assert!(!is_cache_file(Path::new("/photos/IMG_1234.JPG")));
        assert!(!is_cache_file(Path::new("jozin/file.txt")));
    }

    #[test]
    fn test_cleanup_options() {
        let all = CleanupOptions::all();
        assert!(all.sidecars && all.thumbnails && all.backups && all.cache);

        let sidecars = CleanupOptions::sidecars_only();
        assert!(sidecars.sidecars && !sidecars.thumbnails && !sidecars.backups && !sidecars.cache);

        let thumbnails = CleanupOptions::thumbnails_only();
        assert!(
            !thumbnails.sidecars && thumbnails.thumbnails && !thumbnails.backups && !thumbnails.cache
        );
    }

    #[test]
    fn test_cleanup_path_dry_run() {
        let temp_dir = TempDir::new().unwrap();
        let root = temp_dir.path();

        // Create test files
        create_test_file(root, "image.jpg", b"image");
        create_test_file(root, "image.jpg.json", b"sidecar");
        create_test_file(root, "image.jpg.json.bak1", b"backup");
        create_test_file(root, "image_256.jpg", b"thumbnail");

        let result = cleanup_path(root, false, CleanupOptions::all(), true, None).unwrap();

        assert_eq!(result.total_files, 3); // sidecar, backup, thumbnail
        assert_eq!(result.deleted_files.len(), 3);
        assert_eq!(result.failed, 0);

        // Verify nothing was actually deleted
        assert!(root.join("image.jpg.json").exists());
        assert!(root.join("image.jpg.json.bak1").exists());
        assert!(root.join("image_256.jpg").exists());
    }

    #[test]
    fn test_cleanup_sidecars_only() {
        let temp_dir = TempDir::new().unwrap();
        let root = temp_dir.path();

        create_test_file(root, "image.jpg", b"image");
        create_test_file(root, "image.jpg.json", b"sidecar");
        create_test_file(root, "image.jpg.json.bak1", b"backup");
        create_test_file(root, "image_256.jpg", b"thumbnail");

        let result = cleanup_path(root, false, CleanupOptions::sidecars_only(), false, None).unwrap();

        assert_eq!(result.total_files, 1); // Only sidecar
        assert!(!root.join("image.jpg.json").exists());
        assert!(root.join("image.jpg.json.bak1").exists()); // Backup still exists
        assert!(root.join("image_256.jpg").exists()); // Thumbnail still exists
    }

    #[test]
    fn test_cleanup_never_deletes_originals() {
        let temp_dir = TempDir::new().unwrap();
        let root = temp_dir.path();

        create_test_file(root, "image.jpg", b"original image");
        create_test_file(root, "image.jpg.json", b"sidecar");

        cleanup_path(root, false, CleanupOptions::all(), false, None).unwrap();

        // Original must still exist
        assert!(root.join("image.jpg").exists());
        // Sidecar should be deleted
        assert!(!root.join("image.jpg.json").exists());
    }

    #[test]
    fn test_cleanup_recursive() {
        let temp_dir = TempDir::new().unwrap();
        let root = temp_dir.path();

        create_test_file(root, "image1.jpg.json", b"sidecar1");
        create_test_file(root, "subdir/image2.jpg.json", b"sidecar2");
        create_test_file(root, "subdir/nested/image3.jpg.json", b"sidecar3");

        let result = cleanup_path(root, true, CleanupOptions::all(), false, None).unwrap();

        assert_eq!(result.total_files, 3);
        assert!(!root.join("image1.jpg.json").exists());
        assert!(!root.join("subdir/image2.jpg.json").exists());
        assert!(!root.join("subdir/nested/image3.jpg.json").exists());
    }

    #[test]
    fn test_cleanup_non_recursive() {
        let temp_dir = TempDir::new().unwrap();
        let root = temp_dir.path();

        create_test_file(root, "image1.jpg.json", b"sidecar1");
        create_test_file(root, "subdir/image2.jpg.json", b"sidecar2");

        let result = cleanup_path(root, false, CleanupOptions::all(), false, None).unwrap();

        assert_eq!(result.total_files, 1); // Only top-level file
        assert!(!root.join("image1.jpg.json").exists());
        assert!(root.join("subdir/image2.jpg.json").exists()); // Subdirectory file remains
    }

    #[test]
    fn test_cleanup_cache_directory() {
        let temp_dir = TempDir::new().unwrap();
        let root = temp_dir.path();

        create_test_file(root, ".jozin/cache.db", b"cache");
        create_test_file(root, ".jozin/models/model.onnx", b"model");

        let result = cleanup_path(root, true, CleanupOptions::cache_only(), false, None).unwrap();

        assert!(result.total_files >= 2);
        assert!(!root.join(".jozin").exists());
    }

    #[test]
    fn test_cleanup_nonexistent_path() {
        let result = cleanup_path(
            Path::new("/nonexistent/path"),
            false,
            CleanupOptions::all(),
            true,
            None,
        );
        assert!(result.is_err());
        assert!(matches!(result.unwrap_err(), JozinError::IoError { .. }));
    }
}
